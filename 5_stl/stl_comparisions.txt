/*
===============================
ðŸŸ© STL Container Comparisons
===============================
*/

/*
ðŸ”· 1. vector vs list
------------------------------
| Operation         | vector       | list         | Better        |
|------------------|--------------|--------------|---------------|
| Access           | O(1)         | O(n)         | âœ… vector     |
| Insert at end    | O(1)         | O(1)         | âž– Tie         |
| Insert in middle | O(n)         | O(1)*        | âœ… list       |
| Delete in middle | O(n)         | O(1)*        | âœ… list       |
| Cache efficiency | High         | Low          | âœ… vector     |

ðŸŸ¢ Verdict: Use vector for access & cache locality.
            Use list for frequent insert/delete in the middle.
*/

/*
ðŸ”· 2. vector vs deque
------------------------------
| Operation         | vector       | deque        | Better        |
|------------------|--------------|--------------|---------------|
| Push/Pop front   | O(n)         | O(1)         | âœ… deque      |
| Push/Pop back    | O(1)         | O(1)         | âž– Tie         |
| Random access    | O(1)         | O(1)         | âž– Tie         |
| Memory locality  | High         | Moderate     | âœ… vector     |

ðŸŸ¢ Verdict: Use deque for double-ended operations.
            Use vector if front insertions aren't needed.
*/

/*
ðŸ”· 3. set vs unordered_set
------------------------------
| Operation         | set          | unordered_set| Better        |
|------------------|--------------|--------------|---------------|
| Search           | O(log n)     | O(1)*        | âœ… unordered_set |
| Insert/Delete    | O(log n)     | O(1)*        | âœ… unordered_set |
| Maintains order  | Yes          | No           | âœ… set (if needed) |

ðŸŸ¢ Verdict: Use unordered_set for speed, set for ordered data.
*/

/*
ðŸ”· 4. map vs unordered_map
------------------------------
| Operation         | map          | unordered_map| Better        |
|------------------|--------------|--------------|---------------|
| Search           | O(log n)     | O(1)*        | âœ… unordered_map |
| Insert/Delete    | O(log n)     | O(1)*        | âœ… unordered_map |
| Maintains order  | Yes          | No           | âœ… map (if needed) |

ðŸŸ¢ Verdict: Use unordered_map unless ordering is required.
*/

/*
ðŸ”· 5. priority_queue vs set
------------------------------
| Operation         | priority_queue | set         | Better        |
|------------------|----------------|-------------|---------------|
| Top element      | O(1)           | O(1)        | âž– Tie         |
| Insert/Delete    | O(log n)       | O(log n)    | âž– Tie         |
| Allows duplicate | Yes            | No          | âœ… priority_queue |

ðŸŸ¢ Verdict: Use priority_queue for duplicates & fast top().
            Use set for sorted iteration & uniqueness.
*/

/*
ðŸ”· 6. stack/queue vs deque
------------------------------
| Operation         | stack/queue   | deque        | Better        |
|------------------|----------------|--------------|---------------|
| Access           | Limited (LIFO/FIFO) | Random | âœ… deque      |
| Push/Pop         | O(1)           | O(1)         | âž– Tie         |
| Flexibility      | Limited        | High         | âœ… deque      |

ðŸŸ¢ Verdict: stack/queue are wrappers around deque.
            Use deque directly for custom behaviors.
*/

/*
===============================
ðŸ”¶ Summary Table
===============================

| Container        | Best For                            | Search / Insert Time |
|------------------|--------------------------------------|----------------------|
| vector           | Random access, cache efficiency      | O(1) / O(n)          |
| list             | Frequent middle insert/delete        | O(n) / O(1)*         |
| deque            | Double-ended operations              | O(1) / O(1)          |
| set              | Ordered, unique elements             | O(log n) / O(log n)  |
| unordered_set    | Fast lookup, no order                | O(1)* / O(1)*        |
| map              | Key-value with order                 | O(log n) / O(log n)  |
| unordered_map    | Key-value with fast lookup           | O(1)* / O(1)*        |
| priority_queue   | Fast top element, duplicates allowed | O(1) / O(log n)      |

(* average case; worst case for unordered_* is O(n))
*/